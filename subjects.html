
<!doctype html>
<html>

  <head>
    <meta charset="UTF-8">

    <title>Subjects</title>
  </head>
  <body>
      <h1>Examples of possible internship / PhD subjects</h1>

      <!-- <h2> Sort equations for generalised algebraic theories</h2> -->
      <h2> Categorical semantics for untyped syntax and typing judgements</h2>
      Type theories are typically defined "extrinsically" as a syntax and typing judgements, whereas categorical semantics
      assume an "intrinsic" definition of type theories based on generalised algebraic theories (GATs).
      In some specific cases, the formal link between those two approaches is formally established (cf, for example, the case of SOGATs in Uemura's phd, or the correspondance between GATs and EATs in Cartmell's phd).
      All these proofs achieve similar goals; can we unify them in a single setting? 
      Here are some possible research directions:
      <ul>
	      <li>Devise categorical semantics for untyped syntax and typing judgements based on the notion of relative monads;
	      </li>
	      <li>
		      Define a direct semantic translation from inductive-inductive types to indexed inductive types and/or other variants;
	      </li>
	      <li>
		      Extend the <a href="https://drops.dagstuhl.de/opus/volltexte/2020/13070/">construction</a> (in Agda) of finitary quotient inductive-inductive types (QIITs) from indexed inductive types to infinitary ones (QIITs).
	      </li>
	      <li>
		      Handle sort equations in the reduction from GATs to EATs.
	      </li>
      </ul>
      <h2>Mechanising category theory</h2>
      Mechanisation of category theory in proof assistants is a challenging task and a typical benchmark.
      One feature of category theory is that it relies on diagrammatic proofs: they are tedious to translate into formal proofs which are text-based.
The <a href="https://coreact.wiki/">CoREACT project</a> aims at developping a methodology to mechanise diagrammatic reasoning in Coq.
Here are some possible research directions:
<ul>
	<li> improve a prototypical <a href="https://amblafont.github.io/graph-editor/">diagram editor</a> which already supports basic generation of Coq proof scripts from diagrams drawn by the user;
	</li>
	<li> mechanise category theory in Coq using this editor and <a href="https://github.com/CohenCyril/hierarchy-builder">hierarchy builder</a>, a state-of-the-art Coq tool to help building hierarchies of algebraic structures.
	</li>
	</li>
	<li>in particular, mechanise <a href="https://ncatlab.org/nlab/show/locally+presentable+category">locally presentable categories</a>, a ubiquitous categorical notion, based on <a href="https://arxiv.org/abs/2105.03252">recent work on constructive ordinals</a>.
	</li> 
	<li>	exploit this library to mechanise general proofs about programming languages, for example, <a href="articles/wow2.pdf">congruence of bisimilarity based on Howe's method</a>. 
	</li>
</ul>
      <h2>A simple theory of syntax</h2>
      A free variable can be thought of as a constant mevariable. Therefore, by restricting to closed terms with metavariables, we do not "lose" any information.
      From a semantic point of view, this suggests a simple notion of specification for syntax as a functor from [Set, Set] to Set, rather than a pointed strong endofunctor on [Set, Set].
      Which initial algebra semantics do we have in this simpler setting?
      <h2>Categorical semantics of (anti)unification</h2>
      The <a href="https://raw.githubusercontent.com/amblafont/unification/master/draft.pdf">categorical semantics of pattern unification</a>, a decidable fragment of higher-order unification, has been studied in a categorical setting together with an implementation using the Agda proof assistant. Here are some further research directions:
      <ul>
	      <li>Extend the semantics to cover dependently typed languages</li>
	      <li>Devise categorical semantics for <a href="https://academic.oup.com/logcom/article-abstract/6/3/315/1089250?redirectedFrom=fulltext">Qian's efficient pattern unification algorithm</a>, where terms are DAGs rather than trees.
	      </li>
	      <li>Implement a structurally recursive pattern unification algorithm in the style of <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/firstorder-unification-by-structural-recursion/91476025EE07F5E0F81F8F61A0C06C3B">McBride first-order unification algorithm</a> so that Agda can justify termination.</li>
      <!-- <h2>Semantics of algorithmitc typing rules</h2> -->

  </body>
</html>
