
<!doctype html>
<html>
	<!-- Semantics of inductive types with iso

		par exemple, si je prends Nat et que je demande que S est un iso, j'obtiens Z.
		Si je prends le lambda calcul et je demande que abs soit un iso (en tant que module), j'obtiens la syntaxe normalisee. Tu vois le genre ?
		Ce serait rigolode comprendre ca.

	-->

  <head>
    <meta charset="UTF-8">

    <title>Subjects</title>
  </head>
  <body>
      <h1>Examples of possible internship subjects</h1>
      The descriptions below are quite technical; do not hesitate to contact
      me for more explanations.
      <!-- <h2> Sort equations for generalised algebraic theories</h2> -->
      <h2> Semantics of inductive types</h2>
      A type theory is typically defined "extrinsically", that is, as a syntax and typing judgements. However, categorical semantics
      rather rely on a definition of type theories (based on 
      <a href="https://ncatlab.org/nlab/show/generalized+algebraic+theory">generalised algebraic theories</a>, GATs),
      which avoids working with untyped syntax completely. 
      Such an "intrinsic" definition can be formalised in type theory using sophisticated inductive types
      called <a href="https://ncatlab.org/nlab/show/inductive-inductive+type">inductive-inductive types</a>, available 
      in the <a href="https://agda.readthedocs.io">Agda</a> proof assistant but not in <a href="https://coq.inria.fr/">Coq</a>.
      
      There are many variations of this intrinsic/extrinsic gap. In some cases, the formal link between the two approaches is formally established (for example, the case of SOGATs 
      in Uemura's phd, or the correspondance between GATs and EATs in Cartmell's phd).
      We propose to work towards a systematic solution to this problem. Here are some possible research directions.
      <ul>
	      <li>Design categorical semantics for untyped syntax and typing judgements;
	      </li>
	      <li>
		      Define a direct semantic translation from inductive-inductive types to indexed inductive types and/or other variants;
	      </li>
	      <li>
		      Explore variants of the <a href="https://drops.dagstuhl.de/opus/volltexte/2020/13070/">construction</a> (in Agda) of finitary inductive-inductive types from indexed inductive types.
	      </li>
	      <li>
		      Handle sort equations in the constructions of GATs from EATs. This can be used to formalise a type theory with
          <a href="https://ncatlab.org/nlab/show/Russell+universe">Russel universes</a>, as in Coq or Agda.
	      </li>
        <li>
          Design a type theory where inductive types are first-order objects, so that it makes it possible to 
          formalise the theory of inductive types.
        </li>
      </ul>
      <h2 id="mecat">Mechanisation of category theory</h2>
      In the theory of programming languages, mechanisation in proof assistants is 
      becoming more and more popular: it brings more confidence about the 
      proofs which are typically large inductions, and makes them directly reusable.
      Category theory is a major mathematical tool in computer science.
      Its mechanisation is a challenging task and a typical benchmark for proof assistants.
      One feature of category theory is that it relies on diagrammatic proofs: they are tedious to translate into formal proofs, as
      the latter are based on text.
      We propose to work in line of the <a href="https://coreact.wiki/">CoREACT project</a> to 
      to make diagrammatic reasoning in Coq easier.
Here are some possible research directions.
<ul>
	<li>Improve a prototypical <a href="https://amblafont.github.io/graph-editor/">diagram editor</a>, which already supports basic generation of Coq proof scripts from diagrams drawn by the user (see <a href="articles/yade.pdf">here</a> for more explanations);
	</li>
	<li>
	Develop a Coq library to make mechanisation of <a href="https://en.wikipedia.org/wiki/String_diagram">string diagrams</a> easier;
	</li>
	<li> Mechanise category theory in Coq using this editor and <a href="https://github.com/CohenCyril/hierarchy-builder">hierarchy builder</a>, a state-of-the-art Coq tool to help building hierarchies of algebraic structures.
    A possible benchmark would be MacLane's coherence theorem for monoidal categories.
    Another interesting challenge is the mechanisation of <a href="https://ncatlab.org/nlab/show/locally+presentable+category">locally presentable categories</a>, a ubiquitous categorical notion, based on <a href="https://arxiv.org/abs/2105.03252">recent work on constructive ordinals</a>.
	</li>
	<li>	Exploit this library to mechanise some results in the theory of programming languages. This could involve, for example, 
    mechanising <a href="https://raw.githubusercontent.com/amblafont/unification/master/draft.pdf">recent categorical semantics</a> of
     "pattern unification", a decidable fragment of higher-order unification used in major proof assistants:
    <ul>
    <li>Formalise a correctness proof of the algorithm.</li>
    <li>In particular, implement a structurally recursive pattern unification algorithm in the style of <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/firstorder-unification-by-structural-recursion/91476025EE07F5E0F81F8F61A0C06C3B">McBride first-order unification algorithm</a> to justify termination.</li>
    <li>Design categorical semantics for <a href="https://academic.oup.com/logcom/article-abstract/6/3/315/1089250?redirectedFrom=fulltext">Qian's efficient pattern unification algorithm</a>, where terms are DAGs rather than trees, in the spirit of <a href="https://lmcs.episciences.org/1060">"Initial Algebra Semantics for Cyclic Sharing Tree Structures"</a>.
	  <li>Extend the semantics to cover dependently typed languages</li>
      </ul>
	</li>
</ul>
      <h2>A simple theory of syntax</h2>
      A free variable can be thought of as a constant mevariable. Therefore, by restricting to closed terms with metavariables, we do not "lose" any information.
      From a semantic point of view, this suggests a simple notion of specification for syntax as a functor from [Set, Set] to Set, 
      rather than the more involved (standard) notion of pointed strong endofunctor on [Set, Set].
      Initial Algebra semantics need to be worked out in this simpler setting. 

      The motivation for this simple theory of syntax comes from a pending attempt
      to understand the relation between the implementation of a type system involving
      unification and its mathematical specification.
      

        
      <!-- <h2>Semantics of algorithmitc typing rules</h2> -->

  </body>
</html>
