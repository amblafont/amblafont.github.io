<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Main</title>
        <script>
            const renderedClass = "rendered-callback";
            const renderedEvent = "rendered";
        </script>
        <script src="elm.js"></script>
        
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script src="js/katex.min.css.js"></script>
        <script src="js/katex-custom-element.js"></script>
    <script onLoad="initKatex()" 
             defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

       

             <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

        
        <!-- Make foreignobject in svg visible -->
         <style>
          foreignObject { overflow:visible;
          /* to allow clicking through the overflow */
            pointer-events: none
          } 
          foreignObject * { 
              pointer-events: all;
          }
          #canvas {
              width: 4000px;
              height: 4000px;
          }
          .active-edge {
            stroke-width: 4px; 
            
          }
          .weak-active-edge {
            filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));            
          }
          .tabs .tab-button {
  position: relative;
  padding: 0.5em 1em;
  border: 0;
  border-radius: 0.5em;
  background-color: pink;
  box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.5);
  cursor: pointer;
  /* width: 100%;
  max-width: 100%;
   box-sizing: border-box;
  display: block; */
}

          .tabs .tab-button.active-tab, .tabs .tab-button:active {
            top: 2px;
            left: 1px;
            box-shadow: none;

          }
         .active-label { 
             border-color: black;
             border-style: solid;
             border-width: 2px;
             }
             .weak-active-label { 
             border-color: black;
             border-style: dashed;
             border-width: 2px;
             }
             /* selection rectangle */
             .rect-select {
                stroke: black;
                stroke-width: 1px;
                stroke-dasharray: 2;
                fill:transparent;
             }     
            .help-div {
                height: 10em;
                overflow: scroll;
            }
            .overlay .help-div {
                position:fixed;
                top:0;
                bottom:0;
                height:auto;
                right:2px;
                width:50%;                
            }
            .overlay .help-div div {
                background-color: lightgrey;
            }
            path:hover {
                stroke-width : 4;
            }        
            .shadow-line {
                stroke-width: 4px;
                stroke:white;
            }    
        </style> 
        <script>         
            // LocalStorage key used for quicksave
            const storageKey = "yadegraph";
            const gridStorageKey = "yadegridsize"
            const supportStorage = typeof(Storage) !== "undefined";
            var fulltutorial = {"fileName":"graph.json","graph":{"latexPreamble":"\\newcommand{\\coqproof}[1]{\\checkmark}","tabs":[{"active":true,"edges":[{"from":0,"id":4,"label":{"isPullshout":false,"label":"","style":{"alignment":"left","bend":0,"color":"black","dashed":false,"double":false,"head":"default","position":0.5,"tail":"none"},"zindex":0},"to":1},{"from":2,"id":5,"label":{"isPullshout":false,"label":"","style":{"alignment":"left","bend":0,"color":"black","dashed":false,"double":false,"head":"default","position":0.5,"tail":"none"},"zindex":0},"to":4}],"nodes":[{"id":0,"label":{"isMath":true,"label":"A","pos":[458.5,89.39999389648438],"zindex":0}},{"id":1,"label":{"isMath":true,"label":"B","pos":[549.5,89.80001831054688],"zindex":0}},{"id":2,"label":{"isMath":true,"label":"","pos":[460,28.600006103515625],"zindex":0}},{"id":3,"label":{"isMath":true,"label":"A","pos":[364,28.600006103515625],"zindex":0}}],"sizeGrid":96,"title":"1"}]},"version":11};
            var tutorial = fulltutorial["graph"];
            var tutorial_format_version = fulltutorial["version"];

            // electron does not support synchronous window.prompt
            var customPrompt = function(question, defaut, callback) {
                var ret = window.prompt(question, defaut);
                if (ret !== null)                   
                   callback(ret);
            }

            var gridSize = 200;
            if (supportStorage) {
                var result = parseInt(localStorage.getItem(gridStorageKey), 10);
                if (! isNaN(result) && result > 0) {
                    gridSize = result;
                }
            }
            //       if (fulltutorial.hasOwnProperty("graph") && fulltutorial.graph.hasOwnProperty("sizeGrid"))
            //          fulltutorial.graph.sizeGrid = result;
            //       else
            //          alert("Can't update size grid from preferences");
            //    }
            // } 
             
            
            scenarios = {
               "exercise1" : {"graph":{"edges":[{"from":1,"id":12,"label":{"label":"Ff","style":{"alignment":"left","bend":-0.1,"dashed":false,"double":true,"head":"twoheads","position":0.5,"tail":"hook"}},"to":0},{"from":0,"id":13,"label":{"label":"n_y","style":{"alignment":"left","bend":0,"dashed":false,"double":false,"head":"default","position":0.5,"tail":"none"}},"to":2},{"from":1,"id":14,"label":{"label":"n_x","style":{"alignment":"left","bend":0,"dashed":false,"double":false,"head":"default","position":0.5,"tail":"none"}},"to":3},{"from":3,"id":15,"label":{"label":"Gf","style":{"alignment":"left","bend":0,"dashed":false,"double":false,"head":"default","position":0.5,"tail":"none"}},"to":2}],"latexPreamble":"","nodes":[{"id":0,"label":{"isMath":true,"label":"Fy","pos":[531.5,115.33335876464844]}},{"id":1,"label":{"isMath":true,"label":"Fx","pos":[331.5,115.33335876464844]}},{"id":2,"label":{"isMath":true,"label":"Gy","pos":[531.5,315.33335876464844]}},{"id":3,"label":{"isMath":true,"label":"Gx","pos":[331.5,315.33335876464844]}},{"id":4,"label":{"isMath":false,"label":"Number of taken actions so far: \\textbf{$\\depthHistory$}","pos":[82,369.5333251953125]}},{"id":5,"label":{"isMath":false,"label":"Reproduce this square in 4 actions starting from the selected vertex below (mouse is disabled)","pos":[96,30.5333251953125]}},{"id":6,"label":{"isMath":true,"label":"\\bullet","pos":[276,460.18333435058594]}},{"id":7,"label":{"isMath":false,"label":"See hints below.","pos":[82,404.3833312988281]}},{"id":8,"label":{"isMath":false,"label":"- when creating an arrow, use hjkl for keyboard placement, and (>=bB for styling, before validating with TAB (hence jumping to next label)","pos":[126.5,742.3833312988281]}},{"id":9,"label":{"isMath":false,"label":"- to move selection to a close node, use hjkl.","pos":[129.5,786.3833312988281]}},{"id":10,"label":{"isMath":false,"label":"- use 's' to create a square from a node connected to two other nodes","pos":[127,825.2833404541016]}},{"id":11,"label":{"isMath":false,"label":"- rename with 'r'","pos":[130,701.1833343505859]}}],"sizeGrid":200},"version":5},
            };
        </script>
    </head>

    <body>       
        <h1>Diagram editor</h1>
   
     
        <!-- <p>
            A vi-inspired diagram editor, with              
            (latex) labelled nodes and edges, tested with Firefox, written in <a href="https://elm-lang.org/">Elm</a> (see the code on 
        <a href="https://github.com/amblafont/graph-editor-web">github</a>).
            Higher cells are supported.
	    You can draw anywhere, not just on the grid (whose size can be later adjusted).
	    </p>
	    <p>
	    For a LaTeX export, first export to <a href="https://q.uiver.app">Quiver</a> (beware that vertices will be snapped
            to the grid in the process).
	    </p>
	    <p>
            Read the tutorial first, and then try some <a href="?scenario=exercise1">exercise</a>.
        </p>
        <button onclick="loadGraph()" id="load-button" >Load graph</button>
        <button title="Local or session storage" onclick="quickloadGraph()" >QuickLoad graph</button> -->
        
    <!--     <button onclick="dispatchRenderedChildren(document)">
            Recompute the layer
        </button> -->
        
        <!-- first use of katex element. It seems it should be done
        beforehand, otherwise dispatchRendered on the first labelled point  
        gets wrong dimensions.
        -->
        <math-latex> </math-latex>
        <div id="myapp"></div>
        <script>
        const isElectron = window.electronAPI != undefined;
        var appDiv = document.getElementById('myapp');

       
     
        
         
        function dispatchRendered(node) {            
            if (node.clientWidth != null)
                     {
                         // could be optimized by having an additionnal
                         // attribute that tells whether it has
                         // a listener
                         var rect = { width : node.clientWidth , height : node.clientHeight }
                         /* if (node.tagName = "MATH-LATEX") {
                            console.log (rect);
                            console.log (node.getBoundingClientRect());
                         } */
                         node.dispatchEvent(new CustomEvent(renderedEvent, { detail : rect } ));
                     }
        };

        function dispatchRenderedChildren(node) {
            children = node.getElementsByClassName(renderedClass);
                     for (var i = 0; i < children.length; ++i) {
                          dispatchRendered(children[i]);
                      }        
        }
        function fullDispatchRendered(node) {
            dispatchRendered(node);
            if (node.getElementsByClassName != null) {                                                  
                  dispatchRenderedChildren(node);  
            }
        }

         // rendered event handlers
         // Fonction callback à éxécuter quand une mutation est observée
         var callbackMutation = function(mutationsList) {
             for(var mutation of mutationsList) {
	               for(var node of mutation.addedNodes) {
             
                    fullDispatchRendered(node);
                 }
                
	            /*    for(var node of mutation.removedNodes) {
                     if (node.getBoundingClientRect != null)
                     {
                         node.dispatchEvent(new CustomEvent("remove"));
                     }
                 } */
             }
         };

         // Créé une instance de l'observateur lié à la fonction de callback
         var observer = new MutationObserver(callbackMutation);
         observer.observe(appDiv, 
	                        { subtree: true, childList: true }); 

         // initialisation de Elm

         var app = Elm.Main.init({
             node: appDiv,
             flags: { defaultGridSize : gridSize }
         });
         // we send a signal [keyInput] to elm and recieve
         // the answer on [keyOutput]
         function makeElmRequest(keyInput, keyOutput, f) {
            app.ports[keyOutput].subscribe(f);
            return function (data) {
            app.ports[keyInput].send(data);
            }
         }
         // when receiving a signal [keyInput] from Elm
         // we answer by applying [f] and send the result to [keyOutput]
         function answerElmRequestCallback(keyInput, keyOutput, f) {
            var answer = function (data) {
               f(data, function (outData) {
                if (outData)   
                   app.ports[keyOutput].send(outData);
                })
            };
            app.ports[keyInput].subscribe(answer);
            return answer;
         }

         function answerElmRequest(keyInput, keyOutput, f) {
            return answerElmRequestCallback(keyInput, keyOutput, 
               (data, callback) => callback(f(data))                  
            );
         }

         
         


         function sendGraphToElm(json, filename, scenario = "standard", clipboard = false, setFirstTab = false) {
            var graph = json;
            var version = 0;
            if (json.hasOwnProperty('version')) {
               version = json.version;
               graph = json.graph;
            }
            var args = { graph , fileName : filename, scenario,
                clipboard, setFirstTab};
            console.log(args);
            app.ports["loadedGraph" + version].send(args);
         }
        
         const queryString = window.location.search;
         const urlParams = new URLSearchParams(queryString);
         var tutoData = {"graph" : tutorial, "fileName" : "graph.json", "scenario" : "standard", "clipboard" : false, 
        setFirstTab : false };

         if (urlParams.has("scenario") && scenarios.hasOwnProperty(urlParams.get("scenario"))) {
            scenario = urlParams.get("scenario"); 
            sendGraphToElm(scenarios[scenario], scenario + ".json", scenario);
         }
         else {            
            app.ports["loadedGraph" + tutorial_format_version].send(tutoData);
         }
         
         // load a json graph file, send it to the elm component
         function openFile() {
             var input = document.createElement('input');
             input.type = 'file';
             input.accept = ".json";
             input.onchange = e => {
                 var file = e.target.files[0];
                 var fr=new FileReader();
                 fr.onload=function(){
                     var json = JSON.parse (fr.result);
                     sendGraphToElm(json, file.name);
                 }
                 fr.readAsText(file);
                 document.title = file.name;
             }

             input.click();
         };

         if (isElectron)
            app.ports.openFile.subscribe(function (d) {
                window.electronAPI.openFile();
            });
         else
            app.ports.openFile.subscribe(openFile);

        // load a json graph file, from local storage
        function quickloadGraph() {
            if (!supportStorage) {           
               alert("Sorry, your browser does not support Web Storage.");
               return;
            }    
            // we first try loading from the current
            // session storage, to avoid conflicts with
            // other possibly opened tabs
            var result = sessionStorage.getItem(storageKey);
            if (!result) {
                result = localStorage.getItem(storageKey);
                if (result)
                // we put it in the temporary session storage
                    sessionStorage.setItem(storageKey, result);                    
            }
            if (!result) {
                alert('No quicksaved graph found');
                return;
            }
            
            var json = JSON.parse(result);
            var fileName = json.fileName;                  
            sendGraphToElm(json, json.fileName);     
         };



         app.ports.quickLoad.subscribe(quickloadGraph);

         app.ports.alert.subscribe(function(s) {
             alert(s);
         });


         app.ports.select.subscribe(function(id) {
            var elmnt = document.getElementById(id);
            elmnt.select();
         });

         app.ports.computeLayout.subscribe(function(s) {                         
             var children = document.getElementsByClassName(renderedClass);             
             for (var i = 0; i < children.length; ++i) {
                          dispatchRendered(children[i]);
                      }   
         });

         app.ports.preventDefault.subscribe(function (e) {
             e.preventDefault();
         });

                  // asks the user to download some file, generated from content
                  function download(content, fileName, contentType) {
             var a = document.createElement("a");
             var file = new Blob([content], {type: contentType});
             a.href = URL.createObjectURL(file);
             a.download = fileName;
             a.click();
         }

         function fromElmGraph(a) {
             return {graph : a.graph, version : a.version };;
         }

         function quicksaveStorage(arg) {
            console.log("Quicksaving...");
            var a = arg.info
            var d = fromElmGraph(a);
            d.fileName = a.fileName;
             // Check browser support
            if (!supportStorage) {           
               if (arg.feedback)
                   alert("Sorry, your browser does not support Web Storage.");
               return;
            }
            // Store even if the browser is closed
            localStorage.setItem(storageKey, JSON.stringify(d));
            // we put it also in a temporary session storage
            // in case multiple tabs are opened
            sessionStorage.setItem(storageKey, JSON.stringify(d));
            if (arg.feedback)
                alert("Successful quicksave"); 
         }

         if (isElectron)
            app.ports.quicksaveGraph.subscribe(function (a) {
                    var d = a.info;
                    var g = fromElmGraph(d);
                    window.electronAPI.quicksaveGraph(d.fileName, g, a.export, a.feedback);
            });
         else
            app.ports.quicksaveGraph.subscribe(quicksaveStorage);

         app.ports.saveGridSize.subscribe(function(arg) {
            console.log("Saving grid size preferences.");
            // Check browser support
            if (!supportStorage) {           
               alert("Sorry, your browser does not support Web Storage.");
               return;
            }
            // Store even if the browser is closed
            localStorage.setItem(gridStorageKey, arg);                         
         });

         app.ports.exportQuiver.subscribe(function(d) {
             // copied from quiver/quiver.js (export base64)
             var s = `https://q.uiver.app/?q=${
              btoa(unescape(encodeURIComponent(JSON.stringify(d))))}`;
              window.open(s);             
         });

         function saveGraph(b) {
            var a = b.graph;
            var name = a.fileName;
            var d = fromElmGraph(a);
            download(JSON.stringify(d), name /* + '.json' */, 'application/json');
               
            document.title = name;
         };

         if (isElectron)
            app.ports.saveGraph.subscribe(function (d) {
                window.electronAPI.saveGraph(d.graph.fileName, fromElmGraph(d.graph), d.export);
            });
         else
            app.ports.saveGraph.subscribe(saveGraph);


         // this event handler computes the relative position
         // of the mouse with respect to the current target
         // (the one to which the event is attached)
         answerElmRequest('onMouseMove', 'onMouseMoveFromJS', function(e) {
             if ( e.currentTarget) {
                 var rect = e.currentTarget.getBoundingClientRect();
                 var x = e.clientX - rect.left; //x position within the element.
                 var y = e.clientY - rect.top;  //y position within the element.
                 return [x, y];
             }
         });

         document.addEventListener("paste", function (e) { 
                const clipboardData = e.clipboardData || window.clipboardData;
                console.log("paste");

                const text = clipboardData.getData('text') || "";
                // console.log(text);
                var json;
                try { 
                    json = JSON.parse(text);
                 }
                catch (e) { json = false; }
                // console.log(json);
                if (json) {
                    sendGraphToElm(json, "", "standard", true);
                    // cnonsole.log(json);
                }
                // app.ports.onPaste.send(text); 
        });


        // answerElmRequest('decodeGraph', 'decodedGraph', function (paste) {
        //     var json;
        //     try { json = JSON.parse(paste); }
        //     catch (e) { json = false; }
        //     if (json) 
        //        return json.graph
              
        //  })
        


        

         answerElmRequestCallback('promptFindReplace', 'findReplace', (a, callback) =>
         
            customPrompt("Replace in selection (/find/replace, where '/' can be replaced by any character)", 
                  "/find/replace",
                  function (rep) {
             if (rep.length > 2) {
                reps = rep.split(rep[0])                
                if (reps && reps.length == 3 && reps[1]) {
                    var search = reps[1];
                    var replace = reps[2];
                    callback({'search':search, 'replace': replace});
                }
             }
         }) 
         );

         answerElmRequestCallback('promptEquation', 'promptedEquation', (a, callback) =>
            customPrompt("Enter equation", 
                  "a -- f -> b -- g -> c = a -- h -> d -- k -> c", function (rep) {
             if (rep.length > 0) {                
                    callback(rep); //{ equation : rep, final: false, scenario: ""};
             }
            })
         );

         answerElmRequestCallback('promptTabTitle', 'promptedTabTitle', (a, callback) =>
            customPrompt("Rename tab", 
                  a, function (rep) {
            // console.log("reponse: " + rep);
            //  if (rep && rep.length > 0) {                
                    callback(rep); //{ equation : rep, final: false, scenario: ""};
             
            })
         );

         triggerElmCopy = makeElmRequest('onCopy', 'clipboardWriteGraph', function(g) {
            navigator.clipboard.writeText(JSON.stringify(g));                                     
         })

         function toClipboard({content, success, failure}) {
            navigator.clipboard.writeText(content).then(
            () => {
                success && alert(success);
            },
            () => {
                failure && alert(failure);
            });
         };

         app.ports.toClipboard.subscribe(toClipboard);
         const err = "This features is only enabled with the desktop version and the appropriate vscode extension";

         if (isElectron) {
            // app.ports.incompleteEquation.subscribe(function(data){
            //     window.electronAPI.incompleteEquation(data)
            // });
            app.ports.applyProof.subscribe(function(data){ window.electronAPI.applyProof(data) });
            app.ports.requestProof.subscribe((data) => {
                customPrompt("Enter proof for " + data.statement + " (leave blank for interactive)", data.script, (proof) => {
                    newData = {script: proof, statement:data.statement};
                    if (proof == "") {
                        window.electronAPI.incompleteEquation(newData);
                    }
                    else {
                        window.electronAPI.applyProof(newData);
                    }
                });
            });
         }
         else {
            // app.ports.incompleteEquation.subscribe((data) =>  alert(err));
            app.ports.applyProof.subscribe((data) =>  alert(err));
            app.ports.requestProof.subscribe((data) =>  alert(err));
         }

         function copyErr(s, emptyErr, success, failure) {
            if (s == "") {
                alert("No selected subdiagram found!");
                return;
            }
            toClipboard(
                {   content : s,
                    success : success,
                    failure : failure});
         }

         app.ports.generateProofJs.subscribe(function(script) {
            copyErr(script, 
              "No selected diagram found!",
              "Coq script successfully copied",
              "Copy failed"
              );
         });
         app.ports.generateSvg.subscribe(function(svg) {
            copyErr(svg, 
              "No selected diagram found!",
              "SVG code successfully copied",
              "Copy failed"
              );
         });


         document.addEventListener("copy", function(event) {
                    triggerElmCopy(null);
         });
      


         // Elm browser keydown handler is passive
         // and thus cannot prevent default behaviour
         // so we make our custom event listener.
         document.addEventListener("keydown", function(event)  {
                    app.ports.onKeyDownActive.send(event);
         });

         // Setting up interaction with electron
         if (isElectron) {
            customPrompt = function (question, defaut, callback) {
                window.electronAPI.prompt(question, defaut).then(
                    function(rep) {
                        if (rep !== null)
                           callback(rep);
                    });
            };

            console.log("electron detected");
            // window.electronAPI.loadGraph((event, json, fileName, scenario) => alert('coucou') );
            window.electronAPI.loadGraph((event, json, fileName, scenario) => sendGraphToElm(json, fileName, scenario));
            window.electronAPI.clearGraph((event, scenario) => app.ports.clear.send(scenario));
            window.electronAPI.setFirstTab((event, json) => sendGraphToElm(json, "", "coqlsp", false, true));
            window.electronAPI.loadEquation(function (event, equation, scenario) {
                   console.log(equation);
                //   app.ports.clear.send(scenario);
                //   app.ports.promptedEquation.send(equation) ;
                app.ports.setFirstTabEquation.send(equation);
            }
            );
            window.electronAPI.rename((event, fileName) => app.ports.renameFile.send(fileName));
            window.electronAPI.simpleMsg((event, msg) => app.ports.simpleMsg.send(msg));
 
            // }




            app.ports.generateProofJs.subscribe(function(script){
                window.electronAPI.generateProof(script)
            });
            window.electronAPI.appliedProof((event, content) =>
                { app.ports.appliedProof.send(content);}
            );
         }
        
         
        
        </script>
    </body>
</html>
